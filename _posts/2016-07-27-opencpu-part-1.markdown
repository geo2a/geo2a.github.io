---
layout: post
comments: true
title:  "Интеграция R в Web-среду. Часть 1."
date:   2016-11-1
tags: [R, datascience, opencpu, web, backend]
---

Речь пойдёт о моей работе в [statzilla.ru](http://statzilla.ru/), а конкретнее: 
об организации вычислительной части бэкэнда веб-сервиса для анализа данных. 

## Пролог

Вот уже больше года я работаю в стартапе [statzilla.ru](http://statzilla.ru/), где
мы занимаемся оказанием консалтинговых 
услуг в сфере статистической обработки и анализа данных. Многим нашим 
клиентам изо дня в день требуется решать стандартные задачи: производить 
сравнение групп, кластерный анализ, рассчитывать по данным набор описательных 
статистик и производить другие расчёты. Однако самому разобраться с 
профессиональными статистическими пакетами не так-то просто, да и времени на всё 
не хватает. Чтобы помочь научным сотрудникам построить свои исследования на основе 
серьёзного фундамента и использовать для проверки гипотез всю мощь статистики и
анализа данных, мы разрабатываем веб-сервис [Statzilla Science](online.statzilla.ru).       

## Воспроизводимый Анализ и язык R

При проведении сложного анализа данных и последующей презентации результатов 
этого анализа очень важно выработать чёткую методологию и аккуратно прорабатывать 
алгоритмы, по которым проводится анализ. При работе с пакетами статистической 
обработки данных анализ часто производится в интерактивном режиме: аналитик 
считывает данные из файла, а потом с помощью системы меню и диалоговых окон 
выбирает методы анализа и настраивает их параметры. Такой подход удобен для 
первоначального знакомства с данными. Однако когда требуется произвести сложный, 
многошаговый анализ данных, зачастую легко ошибиться и получить некорректные 
результаты. Именно здесь на выручку приходит язык программирования R, который, с 
одной стороны, имеет широкий спектр библиотек с открытым исходным кодом для решения 
любых задач анализа данных, а с другой --- является полноценным языком программирования, 
позволяющим грамотно структурировать алгоритм проведения анализа и оформить 
выработанные методы в собственные библиотеки.          

После того, как команда аналитиков сформулировала алгоритм анализа, программисты 
могут приступать к его реализации. Впоследствии аналитики смогут пользоваться 
готовыми процедурами без необходимости глубоко вникать в язык R.

После отладки и тестирования, проверенные аналитиками R-библиотеки интегрируются 
в веб-сервис и становятся доступны конечным пользователям. Облачённые в интуитивный 
графический интерфейс, эти аналитические средства могут быть использованы клиентами, 
не имеющими серьёзной математической подготовки. 

Итак, перед командой программистов Статзиллы встала задача: найти оптимальный 
способ интеграции R-кода в веб-инфраструктуру. 

## Проблемы метода "по-простому" или почему Rscript не годится для запуска R-кода в веб-среде

Бэкэнд веб-сервиса реализуется на PHP. В первой прототипной реализации 
было принято решение не городить сложных абстракций для вызова R-кода из PHP 
и работать с утилитой Rscript, специально предназначенной 
для пакетного запуска программ на R из консоли. То есть, выглядело это как-то так: 

```
$cmd = "Rscript analisys.R param1 param2";
$r_out = shell_exec($cmdtable);
```

Такой наивный подход хорошо подходил для первого прототипа, но имел ряд
существенных недостатков. 

Во-первых, такой код очень тяжело поддерживать. Конструировать строки вызова для 
консольной утилиты --- дело, в котором очень легко ошибиться, и ошибки такого сорта 
отлавливать довольно сложно. 

Во-вторых, такой подход очень плох с точки зрения разделения полномочий серверов:
веб-сервер и R работают на одной и той же машине и разделяют ресурсы. В то время 
как сам веб-сервер не требует от хоста большой вычислительной мощности, расчёты 
на R могут быть весьма ресурсоёмкими и занимать существенное время.   
Это создало бы серьёзные проблемы при увеличении нагрузки. Такая схема вызова 
R-кода не предоставляет никакой возможности для горизонтального масштабирования 
системы. 

И, в-третьих, такой подход может работать существенно медленнее, чем ожидается
из-за времени, затрачиваемого на инициализацию R-сессии. При каждом запуске 
утилиты Rscript создаётся новая R-сессия, и холодный старт сессии может занимать
существенное время (вплоть до нескольких секунд), если вызываемый скрипт требует 
использования большого количества R-библиотек. R является интерпретируемым языком, 
и первоначальная загрузка библиотек может создавать нежелательный простой системы.

Для решения необходимо выделить вещи, связанные с R, в отдельный вычислительный 
сервис, который будет предоставлять возможность прозрачно вызывать нужные функции 
и не будет никак зависеть от фронтэнд сервера, с которым напрямую взаимодействуют    
пользователи. Будет очень удобно, если этот сервис будет предоставлять HTTP API 
для вызова R-функций, а также будет иметь пулл уже инициализированных R-сессий с 
предварительно загруженными библиотеками. 

Оказалось, что существует opensource-решение, предоставляющее именно такие функции.

## Opencpu

[Opencpu](https://www.opencpu.org/) --- система для интеграции R-кода в веб-среду, 
основанная на пакетах rServe и rApache. Предоставляет возможность работать с 
R-функциями через HTTP API. Рассмотрим небольшой пример. Предположим, что мы
реализовали небольшую R-функцию, которая складывает два числа: 

```
add <- function(x, y) {
    x + y
}
``` 

Мы можем вызвать её с помощью POST-запроса такого вида: 

```
time curl -X POST -L opencpu.hostname.net -H "Content-Type:application/json" -d '{
    , "x": "3"
    , "y": "4"
}'
```

К сожалению, API opencpu немного необычно, и в качестве ответа на такой запрос 
придёт не JSON, а разделённый переводами строки список ссылок на ресурсы.
Забегая немного вперёд, скажу, что одной из текущих задач является разработка 
конфигурации nginx (используется в качестве балансировщика нагрузки), которая 
позволяла бы преобразовывать такой формат тела ответа в JSON. 

```
/ocpu/tmp/<session-id>/R/.val
/ocpu/tmp/<session-id>/stdout
/ocpu/tmp/<session-id>/source
/ocpu/tmp/<session-id>/console
/ocpu/tmp/<session-id>/info
/ocpu/tmp/<session-id>/files/DESCRIPTION
/ocpu/tmp/<session-id>/files/temp
``` 

Здесь session-id --- эту уникальный идентификатор вызова. Наиболее ценными 
ресурсами являются console и .val --- консольный вывод R-сессии и результат 
вычисления. Если R-функция совершает вывод в файл, то ссылка на его загрузку 
также будет доступна. 

Теперь, чтобы получить нужный ресурс, необходимо произвести HTTP GET запрос по 
соответствующему URL.  

Opencpu позволяет с минимальными затратами обернуть R-функции в HTTP API без 
необходимости самостоятельно реализовывать веб-сервер. Однако интеграция 
наших R-библиотек с Opencpu не прошла гладко: возникли существенные проблемы, 
вызванные особенностью архитектуры Opencpu и, внезапно, JVM. 

Об этих проблемах и способах их решения читайте во втором посте серии, который, 
как говорится, coming soon. 

**Ссылки по теме** 

* [Язык R](https://www.r-project.org/)
* [Opencpu](https://www.opencpu.org/) 


{% if post.comments %}
<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/##configuration-variables
     */
    
    // var disqus_config = function () {
    //     this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    //     this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    // };
    
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//geo2a.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
{% endif %}
